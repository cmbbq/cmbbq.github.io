+++
title = "Dev Ergonomics"
date = "2025-01-23"
tags = ["sys", "se"]
description = "思考哪些特性能真正有效地让系统工程师舒适地编程。"
showFullContent = false
+++

## 安全性 vs 灵活性
Rust的借用规则、生命周期、所有权规则在编译期强制检查，使每一行Rust代码都必须达到工业强度，这听起来很美好，但在实际项目中却非常折磨人。因为多数项目，尤其是不确定性较高的新颖系统开发中，必须存在大量demo性质的、测试性质的、探索性质的临时的、ad-hoc的、速朽的、炮灰式的代码。这些代码像无名烈士，在最终成品中消失，却对项目进展起到关键性支撑。

严格安全检查，是Rust最大的卖点，也构成了它的先天不足。当你想临时改个字段、加个参数迅速看个效果，却很容易破坏此前的规约导致无法编译，不得不从接口到结构做完整的重构。这种昂贵、笨重的工作方式类似让精锐技术兵种去填线，换来的仅仅是对内存安全、线程安全、类型安全的绝对确认。绝对确认听起来非常美好，但实际上更多地只是一种受勋仪式。在非生命财产攸关场景下，熟练的C++程序员可以几乎无需额外努力，就大体保证内存安全、线程安全、类型安全，最终不影响系统可靠性，稍微多一些不必要的复制也几乎不会影响到系统性能。实战中真正靠borrow checker修致命问题的程序员，本来也不能胜任系统编程。对合格系统工程师写的代码再额外授予编译器的认可，仪式感大于实际价值。

至少在数据中心应用中，安全性和灵活性取其一，我毫不犹豫会选后者。

## 全局状态
C++中可以简单、安全、方便地使用全局变量和单例。Rust则不得不用``Lazy<AtomicRefCell<T>>``。

全局状态确实会在代码中注入难以测试的干扰，使代码难以测试，难以维护，但也可能简化实现，提升可维护性。其中的利弊权衡应交由程序员根据实际场景做出决定。

## 构建、包管理、依赖管理
[todo: herd]